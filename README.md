# curlstats

Generates, parses and analyzes curl timing statistics against supported endpoints.

Requires curl to generate timed probes. Probes are generated by [curl_http_timing.sh](src/curl_http_timing.sh) script
along with a configuration file specifying the endpoint to be called and options to be used. The
src/curl_config.example file can be used as an example. Be sure to leave the `write-out`
configuration option intact as the parsing by curlstats depends on that format.

## Statistics

A good data set has enough probes to capture most of the scenario's that might occur. For example

  - covering full 24 hour
  - covering all days of a week
  - covering multiple weeks

There is little point in probing very frequently, say 10 up to 30 seconds intervals are fine if one seeks the ability
to pinpoint recurring problems with adequate accuracy. Even higher values can be used to at least spot problems that
can be investigated with more detail.

## Anatomy of a round-trip

Client client/server request/response sequence involves several logical steps involving a number of network
round-trips. Curl provides timing information for each of these steps, and curlstats calls each step a WaitClass.

```
enum WaitClass {
  wcDNS,            /**< The target name needs be resolved to an IP address. */
  wcTCPHandshake,   /**< The TCP layer needs to handshake. */
  wcSSLHandshake,   /**< The TLS layer needs to handshake. */
  wcSendStart,      /**< The client may need time to prepare the data before sending. */
  wcWaitEnd,        /**< The client waited on the first response packet from the peer. */
  wcReceiveEnd      /**< The client spend time retrieving additional network packets. */
};
```

### DNS resolving (DNS)

If the endpoint is not given as an IP (4 or 6) address, the name must be resolved against DNS. DNS queries may
timeout and get retried (elsewhere) showing up as additional spikes in the probe count to response time distribution.
The default timeout value on Linux is 5 seconds (can be overridden in /etc/resolv.conf) so secondary spikes
around 5 seconds indicate DNS response (not resolving) problems. In case the resolve fails entirely, curl will error
CURLE_OPERATION_TIMEDOUT and the probe will not be included in the statistics.

There are known caveats when using ipv6 DNS queries on clients that support both ipv4 and ipv6 transparently
and let the OS decide through AF_UNSPEC what to try and use. The Linux gettadrrinfo call will attempt an ipv6 lookup if
the client supports it, and blocks on the query response (regardless if it is NXDOMAIN).

*The DNS wait class equates to DNS response time, which is the time the DNS server required to assemble the answer plus
the network time before the response hit the client.*

### TCP Handshake (TCP)

The TCP layer performs a handshake to establish a connection. This is almost entirely bound by network latency (in
absence of socket allocation problems). A TCP involves a three-way handshake, the handshake latency is
about 1.5 time the network latency - so a rough estimate of the network latency can be deduced from the TCP
handshake latency.


*The TCP wait class almost always equates to network latency. If the network latency is demonstrated to be fine
by other means, likely other causes are socket and/or CPU starvation problems on either server or client.*

### TLS Handshake (TLS)

If Transport Layer Security is used, TLS needs to handshake as well. The handshake involves establishing
trust on mutual identity, establishing a TLS protocol version and cipher to use, and negotiate a session
key which will be used to encrypt ensuing traffic.

*The TLS wait class equates to network latency and/or CPU starvation on either client or server. However, if
network latency is the dominant factor, that should also be visible in the TCP wait class. If TLS is high and
TCP is low during the same probe, check if the server is having trouble calculating through TLS handshakes.*

### Request send (REQ)

After the TLS handshake completed, the client sends its request data, if any.

*The REQ wait class should be in step with the network latency and network packet size.*

### Response received (RSP)

The first byte of the response is received - so this is the time the client spent waiting on the server's answer,
which is the time the server needed to construct the response plus the time it took before the network
delivered it to the client. If the TCP wait class is low in the same probes, it is safe to assume the time is dominated
by the server response.

*The REQ wait class equates to server response time if TCP wait class is insignificant in the same probes.*

### Response all data received (DAT)

The response may require more than one network packet to return. This is the time it took until the last one was
received.

*The DAT wait class equates to response data transfer. If DAT is high whilst TCP is low, the server may have trouble
presenting the data.*

# Interpreting the output

Any comments in the data (lines starting with a '#') are dumped to stdout as is. The curl_http_timing.sh
script dumps some probing information as comments to the data file, so the context of the output is clear. In the below
case, a 10 second interval sample against www.gnu.org  with a timeout of 10 seconds, from a client named
me.no-ip.org using a local network address, with any optional arguments.

```
#url      = https://www.gnu.org
#interval = 10
#timeout  = 10
#client   = me.no-ip.org
#IP       = 192.168.1.2
#args     =
```

The next sections shows options in effect

```
====================================================
Options in effect
====================================================
Slowness threshold                :   0.050 seconds
Response time distribution bucket :    0.01 seconds
repeating 24h bucket              :      30 minutes
Show trail of slow probes         :       0
```

so the output will consider probes exceeding 0.05 seconds slow, it will use 0.01s buckets in probe count to
response time distribution, use a 30 minute interval to bucket daily statistics, and not show a full trail
of slow probes. See command line examples below.

The QoS section show the % of probes within the specified (-d) slowness threshold. Additionally,
a histogram is shown against response time buckets (-b). The histogram shows that the majority of probes complete within
0.5 seconds, but there is a secondary peak at <  3.500s, 3 seconds above the peak <0.500s. The client producing this
output has a DNS timeout set to 3 seconds - and DNS timeouts are causing the second peak.

```
=============================================================
QoS
=============================================================
94.730% of probes return within 0.500s

probe count to response time distribution, bucket size 0.500s
   bucket    count  %probe
<  0.500s      5321  94.73
<  1.000s        73   1.30
<  1.500s         7   0.12
<  2.000s         2   0.04
<  2.500s         4   0.07
<  3.000s         6   0.11
<  3.500s       172   3.06
<  4.000s        13   0.23
<  4.500s         4   0.07
<  5.000s         3   0.05
<  5.500s         4   0.07
<  6.000s         2   0.04
<  6.500s         1   0.02
<  7.000s         1   0.02
<  7.500s         1   0.02
<  8.000s         1   0.02
<  9.500s         2   0.04
```


```
============================================================================
Global stats
============================================================================
first probe          : 2020-06-13 01:01:01
last  probe          : 2020-06-14 08:46:34
#probes              : 10587
#slow probes         : 242
%slow probes         : 2.286
average response time: 0.331s
optimal response time: 0.208s
estimate network RTT : 19.090ms
class   %slow     min     max     avg  stddev  %rtrip             stability
  DNS   0.472   0.025   9.023   0.047   0.281   14.36         bad (  0.088)
  TCP   0.009   0.023   1.026   0.029   0.011    8.66        good (  2.175)
  TLS   0.170   0.134   0.788   0.184   0.040   55.54   excellent (  3.349)
  REQ   0.000   0.000   0.022   0.000   0.001    0.11         n/a (  0.051)
  RSP   1.634   0.026  16.865   0.070   0.328   21.25         bad (  0.078)
  DAT   0.000   0.000   0.021   0.000   0.001    0.08         n/a (  0.009)
```

## Examples

The generate statistics, copy and edit the src/curl_config.example script

```
url https://www.gnu.org
connect-timeout 10
max-time 10
header "Content-type: application/json"
#header "Accept: application/json"
request GET

# leave as is
silent
output /dev/null

# leave as is otherwise the curlstats parsing will fail to recognize the data
write-out "%{http_connect};%{http_code};%{ssl_verify_result};%{time_total};%{time_namelookup};%{time_connect};%{time_appconnect};%{time_pretransfer};%{time_redirect};%{time_starttransfer}"
```

using the config file the probing can be started with a 10 second interval

```
$ src/curl_http_timing.sh src/curl_config.example 10 | tee data/gnu.org.dat
# probing resumes = 2020-06-14 23:31:09
# client FQDN     = snaak.no-ip.org
# client kernel   = 5.4.38-gentoo
# client OS       = Gentoo/Linux
# client IP       = 192.168.178.2
# curl            = curl 7.69.1 (x86_64-pc-linux-gnu) libcurl/7.69.1 OpenSSL/1.1.1g zlib/1.2.11
# curl            = Release-Date: 2020-03-11
# curl            = Protocols: dict file ftp ftps http https imap imaps ldap ldaps pop3 pop3s rtsp smtp smtps tftp
# curl            = Features: AsynchDNS HTTPS-proxy IPv6 Largefile libz NTLM SSL TLS-SRP UnixSockets
# curl config     = url https://www.gnu.org
# curl config     = connect-timeout 10
# curl config     = max-time 10
# curl config     = header "Accept: text/html"
# curl config     = request GET
# curl config     = silent
# curl config     = output /dev/null
# curl config     = write-out "%{http_connect};%{http_code};%{ssl_verify_result};%{time_total};%{time_namelookup};%{time_connect};%{time_appconnect};%{time_pretransfer};%{time_redirect};%{time_starttransfer}"
# YYYY HH:MI:SS ; curl error ; http connect code ; http response code ; ssl verify result ; total_time ; dns lookup ; tcp handshake ; ssl handshake ; dns lookup+tcp+ssl handshake; redirect time; time to first byte sent
2020-06-14 23:31:09;0;000;200;0;0.529098;0.000371;0.086848;0.268069;0.268094;0.000000;0.356516
2020-06-14 23:31:20;0;000;200;0;0.620587;0.000439;0.114124;0.338221;0.338248;0.000000;0.440422
2020-06-14 23:31:30;0;000;200;0;0.561608;0.000395;0.092362;0.283801;0.283827;0.000000;0.377165
```

The data (in the above case tee-ed to data/gnu.org.dat) can be parsed and analyzed by curlstats:

```
cat data/gnu.org.dat | curlstats
```

Curlstats has several command line options to tweak its behavior

```
usage:
  -b seconds
     (real) response time histogram bucket in seconds
     default: 0.2
  -d minimum
     (real) specify a slow threshold filter in seconds
     default: 1
  -p minimum
     only show histogram buckets with % total probes larger than this value
     default: 0
  -t
     include a full list of slow probes
     default: false
  -T minutes
     (uint) 24 hour time bucket in minutes ( 0 < x <= 60 )
     default: 30
```

### Some command line examples

parse data in curl.log, responses exceeding 0.5 seconds considered 'slow'.

```
$ cat curl.log | curlstats -d 0.5
```

parse data in curl.log, responses exceeding 0.5 seconds considered 'slow', use a 100ms/0.1s call-to-time distribution
bucket

```
$ cat curl.log | curlstats -d 0.5 -b 0.1
```

parse data in curl.log, responses exceeding 0.5 seconds considered 'slow', use a 30 minute 24h time bucket

```
$ cat curl.log | curlstats -d 0.5 -T 30
```

Isolate a single date, responses exceeding 0.5 seconds considered 'slow', use a 5 minute 24h time bucket
and a 0.05s histogram bucket

```
$ grep '^2020-04-20' curl.log | curlstats -d 0.5 -T 5 -b 0.05
```

## Build

requires cmake and a contemporary C++ (c++17) compiler.

```
$ mkdir build
$ cd build
$ cmake .. -DCMAKE_BUILD_TYPE=RELEASE
$ make
```

